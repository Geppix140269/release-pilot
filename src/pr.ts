import * as core from '@actions/core';
import * as github from '@actions/github';
import { Config } from './config';
import { ParsedCommit } from './semver';
import { generateAISummary } from './ai';

const PR_MARKER_START = '<!-- releasepilot:start -->';
const PR_MARKER_END = '<!-- releasepilot:end -->';

export interface PRInfo {
  number: number;
  title: string;
  body: string | null;
  commits: ParsedCommit[];
}

export async function generatePRBody(
  prInfo: PRInfo,
  config: Config,
  commits: ParsedCommit[]
): Promise<string> {
  const summary = await generatePRSummary(commits, config);
  const checklist = generateChecklist(config.prChecklist);
  
  const releasePilotContent = `${PR_MARKER_START}
## üìã Summary

${summary}

## ‚úÖ Checklist

${checklist}

---
*Generated by [ReleasePilot](https://github.com/your-org/release-pilot)*
${PR_MARKER_END}`;

  if (prInfo.body && prInfo.body.includes(PR_MARKER_START)) {
    const startIdx = prInfo.body.indexOf(PR_MARKER_START);
    const endIdx = prInfo.body.indexOf(PR_MARKER_END) + PR_MARKER_END.length;
    
    return prInfo.body.substring(0, startIdx) + 
           releasePilotContent + 
           prInfo.body.substring(endIdx);
  }

  const existingBody = prInfo.body || '';
  return existingBody + (existingBody ? '\n\n' : '') + releasePilotContent;
}

async function generatePRSummary(
  commits: ParsedCommit[],
  config: Config
): Promise<string> {
  const groupedCommits = groupCommitsByType(commits, config);
  
  const useAI = config.aiProvider && (
    process.env.OPENAI_API_KEY || 
    process.env.ANTHROPIC_API_KEY ||
    core.getInput('openai_api_key') ||
    core.getInput('anthropic_api_key')
  );

  if (useAI) {
    try {
      const aiSummary = await generateAISummary(commits, config);
      if (aiSummary) {
        return aiSummary;
      }
    } catch (error) {
      core.warning(`Failed to generate AI summary: ${error}`);
    }
  }

  let summary = '';
  
  for (const [type, typeCommits] of Object.entries(groupedCommits)) {
    if (typeCommits.length === 0) continue;
    
    const emoji = getTypeEmoji(type);
    const heading = getTypeHeading(type);
    
    summary += `### ${emoji} ${heading}\n\n`;
    
    for (const commit of typeCommits) {
      const scope = commit.scope ? `**${commit.scope}:** ` : '';
      summary += `- ${scope}${commit.subject}\n`;
    }
    
    summary += '\n';
  }

  return summary || '*No conventional commits found*';
}

function groupCommitsByType(
  commits: ParsedCommit[],
  config: Config
): Record<string, ParsedCommit[]> {
  const grouped: Record<string, ParsedCommit[]> = {};
  
  for (const section of config.releaseSections) {
    grouped[section] = [];
  }

  for (const commit of commits) {
    if (!commit.type) continue;
    
    if (config.excludedScopes.includes(commit.scope || '')) {
      continue;
    }
    
    if (grouped[commit.type]) {
      grouped[commit.type].push(commit);
    }
  }

  return grouped;
}

function generateChecklist(items: string[]): string {
  return items.map(item => `- [ ] ${item}`).join('\n');
}

function getTypeEmoji(type: string): string {
  const emojiMap: Record<string, string> = {
    feat: '‚ú®',
    fix: 'üêõ',
    perf: '‚ö°',
    refactor: '‚ôªÔ∏è',
    docs: 'üìö',
    style: 'üíÑ',
    test: '‚úÖ',
    build: 'üì¶',
    ci: 'üë∑',
    chore: 'üîß',
    revert: '‚è™'
  };
  
  return emojiMap[type] || 'üìù';
}

function getTypeHeading(type: string): string {
  const headingMap: Record<string, string> = {
    feat: 'Features',
    fix: 'Bug Fixes',
    perf: 'Performance Improvements',
    refactor: 'Code Refactoring',
    docs: 'Documentation',
    style: 'Styles',
    test: 'Tests',
    build: 'Build System',
    ci: 'Continuous Integration',
    chore: 'Chores',
    revert: 'Reverts'
  };
  
  return headingMap[type] || type.charAt(0).toUpperCase() + type.slice(1);
}

export async function updatePRDescription(
  prNumber: number,
  body: string,
  dryRun: boolean = false
): Promise<void> {
  if (dryRun) {
    core.info('[DRY RUN] Would update PR description');
    core.info(`[DRY RUN] New body:\n${body}`);
    return;
  }

  const token = core.getInput('github_token') || process.env.GITHUB_TOKEN;
  if (!token) {
    throw new Error('GitHub token is required');
  }

  const octokit = github.getOctokit(token);
  const context = github.context;

  await octokit.rest.pulls.update({
    owner: context.repo.owner,
    repo: context.repo.repo,
    pull_number: prNumber,
    body: body
  });

  core.info(`Updated PR #${prNumber} description`);
}

export async function getPRInfo(): Promise<PRInfo | null> {
  const context = github.context;
  
  if (context.eventName !== 'pull_request') {
    return null;
  }

  const pr = context.payload.pull_request;
  if (!pr) {
    return null;
  }

  const token = core.getInput('github_token') || process.env.GITHUB_TOKEN;
  if (!token) {
    throw new Error('GitHub token is required');
  }

  const octokit = github.getOctokit(token);
  
  const { data: commits } = await octokit.rest.pulls.listCommits({
    owner: context.repo.owner,
    repo: context.repo.repo,
    pull_number: pr.number
  });

  const parsedCommits = commits.map(c => parseCommit(c.commit.message, c.sha));

  return {
    number: pr.number,
    title: pr.title,
    body: pr.body || null,
    commits: parsedCommits
  };
}

export function parseCommit(message: string, hash: string): ParsedCommit {
  const conventionalCommitRegex = /^(\w+)(?:\(([^)]+)\))?(!)?:\s*(.+)/;
  const firstLine = message.split('\n')[0];
  const match = firstLine.match(conventionalCommitRegex);

  if (!match) {
    return {
      type: null,
      scope: null,
      subject: firstLine,
      breaking: false,
      hash,
      message
    };
  }

  const [, type, scope, breaking, subject] = match;
  const hasBreakingChange = !!breaking || message.includes('BREAKING CHANGE');

  return {
    type,
    scope: scope || null,
    subject,
    breaking: hasBreakingChange,
    notes: hasBreakingChange ? [{ title: 'BREAKING CHANGE', text: '' }] : undefined,
    footer: message.includes('BREAKING CHANGE') ? message.split('BREAKING CHANGE')[1] : undefined,
    hash,
    message
  };
}