"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.generatePRBody = generatePRBody;
exports.updatePRDescription = updatePRDescription;
exports.getPRInfo = getPRInfo;
exports.parseCommit = parseCommit;
const core = __importStar(require("@actions/core"));
const github = __importStar(require("@actions/github"));
const ai_1 = require("./ai");
const PR_MARKER_START = '<!-- releasepilot:start -->';
const PR_MARKER_END = '<!-- releasepilot:end -->';
async function generatePRBody(prInfo, config, commits) {
    const summary = await generatePRSummary(commits, config);
    const checklist = generateChecklist(config.prChecklist);
    const releasePilotContent = `${PR_MARKER_START}
## ðŸ“‹ Summary

${summary}

## âœ… Checklist

${checklist}

---
*Generated by [ReleasePilot](https://github.com/your-org/release-pilot)*
${PR_MARKER_END}`;
    if (prInfo.body && prInfo.body.includes(PR_MARKER_START)) {
        const startIdx = prInfo.body.indexOf(PR_MARKER_START);
        const endIdx = prInfo.body.indexOf(PR_MARKER_END) + PR_MARKER_END.length;
        return prInfo.body.substring(0, startIdx) +
            releasePilotContent +
            prInfo.body.substring(endIdx);
    }
    const existingBody = prInfo.body || '';
    return existingBody + (existingBody ? '\n\n' : '') + releasePilotContent;
}
async function generatePRSummary(commits, config) {
    const groupedCommits = groupCommitsByType(commits, config);
    const useAI = config.aiProvider && (process.env.OPENAI_API_KEY ||
        process.env.ANTHROPIC_API_KEY ||
        core.getInput('openai_api_key') ||
        core.getInput('anthropic_api_key'));
    if (useAI) {
        try {
            const aiSummary = await (0, ai_1.generateAISummary)(commits, config);
            if (aiSummary) {
                return aiSummary;
            }
        }
        catch (error) {
            core.warning(`Failed to generate AI summary: ${error}`);
        }
    }
    let summary = '';
    for (const [type, typeCommits] of Object.entries(groupedCommits)) {
        if (typeCommits.length === 0)
            continue;
        const emoji = getTypeEmoji(type);
        const heading = getTypeHeading(type);
        summary += `### ${emoji} ${heading}\n\n`;
        for (const commit of typeCommits) {
            const scope = commit.scope ? `**${commit.scope}:** ` : '';
            summary += `- ${scope}${commit.subject}\n`;
        }
        summary += '\n';
    }
    return summary || '*No conventional commits found*';
}
function groupCommitsByType(commits, config) {
    const grouped = {};
    for (const section of config.releaseSections) {
        grouped[section] = [];
    }
    for (const commit of commits) {
        if (!commit.type)
            continue;
        if (config.excludedScopes.includes(commit.scope || '')) {
            continue;
        }
        if (grouped[commit.type]) {
            grouped[commit.type].push(commit);
        }
    }
    return grouped;
}
function generateChecklist(items) {
    return items.map(item => `- [ ] ${item}`).join('\n');
}
function getTypeEmoji(type) {
    const emojiMap = {
        feat: 'âœ¨',
        fix: 'ðŸ›',
        perf: 'âš¡',
        refactor: 'â™»ï¸',
        docs: 'ðŸ“š',
        style: 'ðŸ’„',
        test: 'âœ…',
        build: 'ðŸ“¦',
        ci: 'ðŸ‘·',
        chore: 'ðŸ”§',
        revert: 'âª'
    };
    return emojiMap[type] || 'ðŸ“';
}
function getTypeHeading(type) {
    const headingMap = {
        feat: 'Features',
        fix: 'Bug Fixes',
        perf: 'Performance Improvements',
        refactor: 'Code Refactoring',
        docs: 'Documentation',
        style: 'Styles',
        test: 'Tests',
        build: 'Build System',
        ci: 'Continuous Integration',
        chore: 'Chores',
        revert: 'Reverts'
    };
    return headingMap[type] || type.charAt(0).toUpperCase() + type.slice(1);
}
async function updatePRDescription(prNumber, body, dryRun = false) {
    if (dryRun) {
        core.info('[DRY RUN] Would update PR description');
        core.info(`[DRY RUN] New body:\n${body}`);
        return;
    }
    const token = core.getInput('github_token') || process.env.GITHUB_TOKEN;
    if (!token) {
        throw new Error('GitHub token is required');
    }
    const octokit = github.getOctokit(token);
    const context = github.context;
    await octokit.rest.pulls.update({
        owner: context.repo.owner,
        repo: context.repo.repo,
        pull_number: prNumber,
        body: body
    });
    core.info(`Updated PR #${prNumber} description`);
}
async function getPRInfo() {
    const context = github.context;
    if (context.eventName !== 'pull_request') {
        return null;
    }
    const pr = context.payload.pull_request;
    if (!pr) {
        return null;
    }
    const token = core.getInput('github_token') || process.env.GITHUB_TOKEN;
    if (!token) {
        throw new Error('GitHub token is required');
    }
    const octokit = github.getOctokit(token);
    const { data: commits } = await octokit.rest.pulls.listCommits({
        owner: context.repo.owner,
        repo: context.repo.repo,
        pull_number: pr.number
    });
    const parsedCommits = commits.map(c => parseCommit(c.commit.message, c.sha));
    return {
        number: pr.number,
        title: pr.title,
        body: pr.body || null,
        commits: parsedCommits
    };
}
function parseCommit(message, hash) {
    const conventionalCommitRegex = /^(\w+)(?:\(([^)]+)\))?(!)?:\s*(.+)/;
    const firstLine = message.split('\n')[0];
    const match = firstLine.match(conventionalCommitRegex);
    if (!match) {
        return {
            type: null,
            scope: null,
            subject: firstLine,
            breaking: false,
            hash,
            message
        };
    }
    const [, type, scope, breaking, subject] = match;
    const hasBreakingChange = !!breaking || message.includes('BREAKING CHANGE');
    return {
        type,
        scope: scope || null,
        subject,
        breaking: hasBreakingChange,
        notes: hasBreakingChange ? [{ title: 'BREAKING CHANGE', text: '' }] : undefined,
        footer: message.includes('BREAKING CHANGE') ? message.split('BREAKING CHANGE')[1] : undefined,
        hash,
        message
    };
}
//# sourceMappingURL=pr.js.map